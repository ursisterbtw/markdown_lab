<!DOCTYPE html>
<html>
<head>
    <title>Large Sample Document for Benchmarking</title>
</head>
<body>
    <h1>Introduction to Performance Testing</h1>
    <p>This document contains a substantial amount of content to test the performance characteristics of our HTML to Markdown converter. We'll include various HTML elements to ensure comprehensive testing.</p>
    
    <h2>Chapter 1: Getting Started</h2>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
    <p>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
    
    <h3>Section 1.1: Basic Concepts</h3>
    <p>Here we have <a href="https://example.com/link1">an important link</a> and <a href="/relative/path">a relative link</a>. We also have <strong>bold text</strong> and <em>italic text</em> for emphasis.</p>
    
    <ul>
        <li>First item in the list</li>
        <li>Second item with <a href="https://example.com/link2">embedded link</a></li>
        <li>Third item with nested content
            <ul>
                <li>Nested item 1</li>
                <li>Nested item 2</li>
            </ul>
        </li>
    </ul>
    
    <h3>Section 1.2: Advanced Topics</h3>
    <p>Let's include some code examples to test code block handling:</p>
    
    <pre><code class="language-python">
def fibonacci(n):
    """Calculate fibonacci sequence up to n terms."""
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    else:
        fib = [0, 1]
        for i in range(2, n):
            fib.append(fib[i-1] + fib[i-2])
        return fib

# Example usage
print(fibonacci(10))
    </code></pre>
    
    <blockquote>
        "Performance is not just about speed, it's about efficiency and resource utilization." - Anonymous Developer
    </blockquote>
    
    <h2>Chapter 2: Implementation Details</h2>
    <p>In this chapter, we'll explore various implementation strategies and their trade-offs. Understanding these concepts is crucial for optimizing performance.</p>
    
    <ol>
        <li>Memory allocation strategies</li>
        <li>String handling optimizations</li>
        <li>Zero-copy techniques</li>
        <li>Lazy evaluation patterns</li>
    </ol>
    
    <h3>Section 2.1: Memory Management</h3>
    <p>Efficient memory management is key to performance. Here's an example in Rust:</p>
    
    <pre><code class="language-rust">
use std::borrow::Cow;

fn process_string<'a>(input: &'a str) -> Cow<'a, str> {
    if input.contains("old") {
        Cow::Owned(input.replace("old", "new"))
    } else {
        Cow::Borrowed(input)
    }
}
    </code></pre>
    
    <p>This approach allows us to avoid unnecessary allocations when the string doesn't need modification.</p>
    
    <h3>Section 2.2: Benchmarking Results</h3>
    <p>Here are some images representing our benchmarking results:</p>
    <img src="/images/benchmark1.png" alt="Benchmark results showing 50% improvement">
    <img src="/images/benchmark2.png" alt="Memory usage comparison">
    
    <table>
        <tr>
            <th>Operation</th>
            <th>Standard (ms)</th>
            <th>Zero-copy (ms)</th>
            <th>Improvement</th>
        </tr>
        <tr>
            <td>Parse HTML</td>
            <td>12.5</td>
            <td>8.3</td>
            <td>33.6%</td>
        </tr>
        <tr>
            <td>Generate Markdown</td>
            <td>5.2</td>
            <td>3.1</td>
            <td>40.4%</td>
        </tr>
    </table>
    
    <h2>Chapter 3: Real-world Applications</h2>
    <p>The optimizations we've implemented have significant impact in real-world scenarios. Let's examine several use cases where these improvements make a substantial difference.</p>
    
    <h3>Section 3.1: Large-scale Document Processing</h3>
    <p>When processing thousands of documents, even small optimizations compound into significant time savings. Consider a scenario where we need to convert 10,000 HTML documents to Markdown:</p>
    
    <ul>
        <li>Standard approach: 10,000 × 17.7ms = 177 seconds</li>
        <li>Zero-copy approach: 10,000 × 11.4ms = 114 seconds</li>
        <li>Time saved: 63 seconds (35.6% improvement)</li>
    </ul>
    
    <h3>Section 3.2: Memory-constrained Environments</h3>
    <p>In containerized environments or edge computing scenarios, memory efficiency is crucial. Our zero-copy optimizations reduce memory pressure by:</p>
    
    <ol>
        <li>Avoiding unnecessary string duplications</li>
        <li>Reusing existing allocations where possible</li>
        <li>Leveraging Rust's ownership system for efficiency</li>
    </ol>
    
    <blockquote>
        "Premature optimization is the root of all evil, but that doesn't mean we should ignore obvious inefficiencies." - Donald Knuth (paraphrased)
    </blockquote>
    
    <h2>Conclusion</h2>
    <p>Through careful application of zero-copy techniques and other optimizations, we've achieved significant performance improvements in our HTML to Markdown converter. These improvements translate directly to better user experience and reduced infrastructure costs.</p>
    
    <p>For more information, visit our <a href="https://github.com/example/project">GitHub repository</a> or check out the <a href="https://docs.example.com">documentation</a>.</p>
</body>
</html>