# Ask HN: Interesting TUIs (text user interfaces), maybe forgotten ones? | Hacker News

![image](https://news.ycombinator.com/y18.svg)

(I'm only familiar with a handful of modern ones in Emacs—Magit, the SLIME inspector, dired, as well as the terminal TUI from the Linux tool perf).

![image](https://news.ycombinator.com/s.gif)

https://terminaltrove.com/And it also features a great list of them here that many might not have heard of.https://terminaltrove.com/list/For example trippy and nvtop look very nice for TUIs and other 'top' based tools they have listed there.https://terminaltrove.com/categories/top/https://terminaltrove.com/trippy/https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

And it also features a great list of them here that many might not have heard of.https://terminaltrove.com/list/For example trippy and nvtop look very nice for TUIs and other 'top' based tools they have listed there.https://terminaltrove.com/categories/top/https://terminaltrove.com/trippy/https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

https://terminaltrove.com/list/For example trippy and nvtop look very nice for TUIs and other 'top' based tools they have listed there.https://terminaltrove.com/categories/top/https://terminaltrove.com/trippy/https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

For example trippy and nvtop look very nice for TUIs and other 'top' based tools they have listed there.https://terminaltrove.com/categories/top/https://terminaltrove.com/trippy/https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

https://terminaltrove.com/categories/top/https://terminaltrove.com/trippy/https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

https://terminaltrove.com/trippy/https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

https://terminaltrove.com/nvtop/There's screenshots and install instructions that's also convenient.

There's screenshots and install instructions that's also convenient.

![image](https://news.ycombinator.com/s.gif)

You can find reviews of hundreds of CLI And TUI programs, some great, others barely known and clearly forgotten. The last review is from 2015. Some reviews are very short, others are more involved.The site is a blog with a tagline "Adventures with lightweight and minimalist software for Linux". The author K.Mandla is opinionated and has certain preferences for such programs like [1].I have not looked at the site in years, but if you are willing to explore, this could be a fun option to find a variety of these tools.[1]: https://inconsolation.wordpress.com/2015/01/19/wpe-and-we-so...

The site is a blog with a tagline "Adventures with lightweight and minimalist software for Linux". The author K.Mandla is opinionated and has certain preferences for such programs like [1].I have not looked at the site in years, but if you are willing to explore, this could be a fun option to find a variety of these tools.[1]: https://inconsolation.wordpress.com/2015/01/19/wpe-and-we-so...

I have not looked at the site in years, but if you are willing to explore, this could be a fun option to find a variety of these tools.[1]: https://inconsolation.wordpress.com/2015/01/19/wpe-and-we-so...

[1]: https://inconsolation.wordpress.com/2015/01/19/wpe-and-we-so...

![image](https://news.ycombinator.com/s.gif)

https://github.com/cosmos72/twinA text mode environment and window manager, with terminal emulation, VNC-style sessions and viewers, and networked clients.Disclaimer: I'm the author

A text mode environment and window manager, with terminal emulation, VNC-style sessions and viewers, and networked clients.Disclaimer: I'm the author

Disclaimer: I'm the author

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Some things I observe from watching these apps is that navigation clues are always present, keymappings are static from screen to screen (F1 is always help, say), and the UI is such that the user is always in control of the application state.

![image](https://news.ycombinator.com/s.gif)

Sitting in large offices with rows of desks and a huge clock on the front wall, they weren't interacting with customers, they were transcribing from sales sheets, order forms, application forms, etc. prepared by someone else.There was no great need for user friendliness, because the only users were in house, and they performed the same data entry hundreds of times every day.The only need was for speed.The arrival of the PC started changing everything, as people got familiar with the mouse and GUI.Somehow mouse-based GUIs became the default for everything, which made a lot of sense as at the same time data entry was pushed out to the users themselves and intermediary data entry staff disappeared.But if you want a fast, simple way to quickly perform common transactions even on very small screens, old school TUIs have a lot to learn from.

There was no great need for user friendliness, because the only users were in house, and they performed the same data entry hundreds of times every day.The only need was for speed.The arrival of the PC started changing everything, as people got familiar with the mouse and GUI.Somehow mouse-based GUIs became the default for everything, which made a lot of sense as at the same time data entry was pushed out to the users themselves and intermediary data entry staff disappeared.But if you want a fast, simple way to quickly perform common transactions even on very small screens, old school TUIs have a lot to learn from.

The only need was for speed.The arrival of the PC started changing everything, as people got familiar with the mouse and GUI.Somehow mouse-based GUIs became the default for everything, which made a lot of sense as at the same time data entry was pushed out to the users themselves and intermediary data entry staff disappeared.But if you want a fast, simple way to quickly perform common transactions even on very small screens, old school TUIs have a lot to learn from.

The arrival of the PC started changing everything, as people got familiar with the mouse and GUI.Somehow mouse-based GUIs became the default for everything, which made a lot of sense as at the same time data entry was pushed out to the users themselves and intermediary data entry staff disappeared.But if you want a fast, simple way to quickly perform common transactions even on very small screens, old school TUIs have a lot to learn from.

Somehow mouse-based GUIs became the default for everything, which made a lot of sense as at the same time data entry was pushed out to the users themselves and intermediary data entry staff disappeared.But if you want a fast, simple way to quickly perform common transactions even on very small screens, old school TUIs have a lot to learn from.

But if you want a fast, simple way to quickly perform common transactions even on very small screens, old school TUIs have a lot to learn from.

![image](https://news.ycombinator.com/s.gif)

Keyboards are just faster once you learn them.

![image](https://news.ycombinator.com/s.gif)

In a traditional TUI you can type at full speed and the system will process the keystrokes as it is able, with no keystrokes being lost. If a keystroke calls up a new screen, then the very next keystroke will apply to that screen. Competent users could be several screens ahead of the computer, because the system doesn't make them wait for the UI to appear before accepting the keystrokes that will apply to that UI.

![image](https://news.ycombinator.com/s.gif)

Reminds me of https://en.wikipedia.org/wiki/Therac-25

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It's not something windows does or can disallow. You just focus the window in the code and that's it.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

What works best is heavily task dependent, and also needs to account for cognitive load and training requirements. Stations with few primary tasks taking limited input (e.g., product lookup forms and customer purchase forms) lend themselves heavily to a keyboard driven UI, but many others either do not. In that area, it ends up just being a strong personal preference guiding what seems best.

![image](https://news.ycombinator.com/s.gif)

My girlfriend works in a bank and she does virtually everything in a TUI.She hates it, but I've seen her using it and she's blazing fast and I can't, as a frontend developer, imagine how a full blown application would be better.

She hates it, but I've seen her using it and she's blazing fast and I can't, as a frontend developer, imagine how a full blown application would be better.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Copy pasting is also troublesome, and that one is a common scenario to copy/paste from emails.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

On my side I'd much rather have the efficient UI but I can imagine people getting tired if their mind is working 100% all the time.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

But it would require people to use full size extended keyboard (function F rows, numpads, etc). Which shrinks the user base quite a bit.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Whereas in indie coffee shops they use a Square tablet and in Apple stores the store people just use iPhones with special cases. Best Buy or Walgreens uses POS tablets with a relatively ugly GUI.Legacy apps never die. Charles Schwab might use mainframes while Robinhood won't but Schwab won't move off because it's too hard for an established firm. Same with Costco TUIs.

Legacy apps never die. Charles Schwab might use mainframes while Robinhood won't but Schwab won't move off because it's too hard for an established firm. Same with Costco TUIs.

![image](https://news.ycombinator.com/s.gif)

I think it's a mistake to frame this as legacy vs. new. There are real benefits to the approach taken by these TUI applications and it would behoove modern app designers to learn from them.It's perhaps the case that those coffee shops will someday adopt a TUI once they reach a level of sophistication. As an example: I believe Starbucks uses a TUI for order processing.

It's perhaps the case that those coffee shops will someday adopt a TUI once they reach a level of sophistication. As an example: I believe Starbucks uses a TUI for order processing.

![image](https://news.ycombinator.com/s.gif)

At least at the time, it sounded like they made a completely new application... and explicitly went with this stack.Now, before you point to Amadeus still being command oriented just like that, modern Amadeus is accessed over GUI client - even if you're going to use all console commands.Meanwhile when I had to reschedule a flight due to a volcano exploding and grounding all planes, I got to see what the KLM/AF local agent did. Fullscreen red-on-black TN3270 session. Took only a moment to handle my case and throw in a few extras.

Now, before you point to Amadeus still being command oriented just like that, modern Amadeus is accessed over GUI client - even if you're going to use all console commands.Meanwhile when I had to reschedule a flight due to a volcano exploding and grounding all planes, I got to see what the KLM/AF local agent did. Fullscreen red-on-black TN3270 session. Took only a moment to handle my case and throw in a few extras.

Meanwhile when I had to reschedule a flight due to a volcano exploding and grounding all planes, I got to see what the KLM/AF local agent did. Fullscreen red-on-black TN3270 session. Took only a moment to handle my case and throw in a few extras.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

- Excel- 3D modeling tools- Adobe Creative apps- Programming IDEs- ?Also, if you are focused on that metric: the productivity of the power user, then in many cases adopting a more modern GUI framework will not necessarily make it easier to achieve that goal (and in some cases may make it harder).

- 3D modeling tools- Adobe Creative apps- Programming IDEs- ?Also, if you are focused on that metric: the productivity of the power user, then in many cases adopting a more modern GUI framework will not necessarily make it easier to achieve that goal (and in some cases may make it harder).

- Adobe Creative apps- Programming IDEs- ?Also, if you are focused on that metric: the productivity of the power user, then in many cases adopting a more modern GUI framework will not necessarily make it easier to achieve that goal (and in some cases may make it harder).

- Programming IDEs- ?Also, if you are focused on that metric: the productivity of the power user, then in many cases adopting a more modern GUI framework will not necessarily make it easier to achieve that goal (and in some cases may make it harder).

- ?Also, if you are focused on that metric: the productivity of the power user, then in many cases adopting a more modern GUI framework will not necessarily make it easier to achieve that goal (and in some cases may make it harder).

Also, if you are focused on that metric: the productivity of the power user, then in many cases adopting a more modern GUI framework will not necessarily make it easier to achieve that goal (and in some cases may make it harder).

![image](https://news.ycombinator.com/s.gif)

Thus there is no innate framework benefit, only downside, so it doesn't make sense to handicap yourself tying to this legacy

![image](https://news.ycombinator.com/s.gif)

And that can be a nice improvement to e. g show your code at a normal size but pop a tooltip up with smaller text, or have the linter/errors tab be a smaller font.But that's a difference and not necessarily an improvement, because having a consistent font and fixed width text can make things more predictable and faster to interact with as you don't have to scan around as much.

But that's a difference and not necessarily an improvement, because having a consistent font and fixed width text can make things more predictable and faster to interact with as you don't have to scan around as much.

![image](https://news.ycombinator.com/s.gif)

> fixed width text can make things more predictable and faster to interact with as you don't have to scan around as much.In what way does "i" not looking as wide as "w" force any scan speed deterioration?

In what way does "i" not looking as wide as "w" force any scan speed deterioration?

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

These folks were fast in the TUI but extending them to 2-4x the workspace was an insane productivity booster. This yard ended up being bought out in part to how we managed to extend email and virtual terminal capabilities and was the basis for the footprint of the LKQ brand at the time. I'm not sure how any web app could compete. TUIs are amazing workflow enablers.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Did some work for Lowe's Home improvement and their PXE booting thin clients in the early 2000's.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

If you spend a couple 8 hour days doing returns or checking people into flights or whatever, you'll get good at the regular stuff and the usual exceptions. Or you won't and maybe there's something else you can do.Most of the time, the real tricks are knowing how to move to the other fields when it's not obviously tab, and what the button is to get into the exception menu. And then learning the layouts to scan the page for what you need.On a mouse driven system you can usually click into the fields you need, but if you need to, it's usually gonna be slow.

Most of the time, the real tricks are knowing how to move to the other fields when it's not obviously tab, and what the button is to get into the exception menu. And then learning the layouts to scan the page for what you need.On a mouse driven system you can usually click into the fields you need, but if you need to, it's usually gonna be slow.

On a mouse driven system you can usually click into the fields you need, but if you need to, it's usually gonna be slow.

![image](https://news.ycombinator.com/s.gif)

What magic makes TUI faster than GUI?TUI just use glyphs to render the interface. AFAIK that's not faster that a proper graphics engine.Keyboard shortcuts are not exclusive to TUI.Maybe if we would stop hyping UI gimmicks and put more focus on fundamentals, there wouldn't be so many bad GUI apps.

TUI just use glyphs to render the interface. AFAIK that's not faster that a proper graphics engine.Keyboard shortcuts are not exclusive to TUI.Maybe if we would stop hyping UI gimmicks and put more focus on fundamentals, there wouldn't be so many bad GUI apps.

Keyboard shortcuts are not exclusive to TUI.Maybe if we would stop hyping UI gimmicks and put more focus on fundamentals, there wouldn't be so many bad GUI apps.

Maybe if we would stop hyping UI gimmicks and put more focus on fundamentals, there wouldn't be so many bad GUI apps.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

The only difference is that TUIs are worse at displaying... text (and graphics)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

While they've modernized a front-end to GENESIS (see their current POS deployment), there's still an option to dump the system back into a TUI for advanced features (the Alt+F12 option).https://i.redd.it/to1k7tbsq9b51.jpg

https://i.redd.it/to1k7tbsq9b51.jpg

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Charva - http://www.pitman.co.za/projects/charva/index.htmlAbsTK - https://gobolinux.org/abstk/

AbsTK - https://gobolinux.org/abstk/

![image](https://news.ycombinator.com/s.gif)

[1] https://github.com/Textualize/textual

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

You could easily browse through the menu hierarchy, but still memorize certain shortcuts that you often use (just like Windows). In later versions you could even use the mouse to select things if you wanted to. It didn't try to force any one particular method onto you, but let you use the input you're most comfortable with.So many CLI tools are incredibly idiomatic and require you to do something in a very particular way with no on screen hints. Even the help screen is normally hidden behind some key combo. TUI or not, that seems unnecessarily elitist.I think some of the old telnet MUDs or BBS games are nice to learn from, whether they used helpful text prompts (you are here, this is what you can do) or just rendered graphical menus in ASCII with colors. For some reason I still don't quite understand, games still seem to have more UI focus than productivity apps. Maybe cuz they tend to target the general public instead of B2B users?Another pattern I really like: In more modern GUI IDEs and editors like Sublime or Jetbrains or VScode, you can usually launch a floating command input bar that will search through available files, commands, settings, etc. That lets you quickly find the thing you want without knowing the key combo for it (like format code, or forking a branch, or turning off word wrap). It would be cool to have a LLM layer in there that could parse natural language (instead of a basic keyword search) and execute commands based on that.

So many CLI tools are incredibly idiomatic and require you to do something in a very particular way with no on screen hints. Even the help screen is normally hidden behind some key combo. TUI or not, that seems unnecessarily elitist.I think some of the old telnet MUDs or BBS games are nice to learn from, whether they used helpful text prompts (you are here, this is what you can do) or just rendered graphical menus in ASCII with colors. For some reason I still don't quite understand, games still seem to have more UI focus than productivity apps. Maybe cuz they tend to target the general public instead of B2B users?Another pattern I really like: In more modern GUI IDEs and editors like Sublime or Jetbrains or VScode, you can usually launch a floating command input bar that will search through available files, commands, settings, etc. That lets you quickly find the thing you want without knowing the key combo for it (like format code, or forking a branch, or turning off word wrap). It would be cool to have a LLM layer in there that could parse natural language (instead of a basic keyword search) and execute commands based on that.

I think some of the old telnet MUDs or BBS games are nice to learn from, whether they used helpful text prompts (you are here, this is what you can do) or just rendered graphical menus in ASCII with colors. For some reason I still don't quite understand, games still seem to have more UI focus than productivity apps. Maybe cuz they tend to target the general public instead of B2B users?Another pattern I really like: In more modern GUI IDEs and editors like Sublime or Jetbrains or VScode, you can usually launch a floating command input bar that will search through available files, commands, settings, etc. That lets you quickly find the thing you want without knowing the key combo for it (like format code, or forking a branch, or turning off word wrap). It would be cool to have a LLM layer in there that could parse natural language (instead of a basic keyword search) and execute commands based on that.

Another pattern I really like: In more modern GUI IDEs and editors like Sublime or Jetbrains or VScode, you can usually launch a floating command input bar that will search through available files, commands, settings, etc. That lets you quickly find the thing you want without knowing the key combo for it (like format code, or forking a branch, or turning off word wrap). It would be cool to have a LLM layer in there that could parse natural language (instead of a basic keyword search) and execute commands based on that.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://en.wikipedia.org/wiki/Gorillas_(video_game)also Money, and REMLINE

also Money, and REMLINE

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

The UI was refered to as COW character oriented windows. It would be good if it could be open sourced, for historical reference.There were other interesting TUIs, the one in Defrag in DOS, and the Antivirus would change characters on the fly to generate a mouse cursor.The TUI in DOSSHELL.exe would use customise some characters to draw icons.Maybe Scott Hanselman could be persuaded to work on open sourcing all the COW apps.(Honarable mention for EDIT in DOS7, which appears to be a rewrite, supporting long filenames).In the modern era, there is YEdit from the author of YCmd, which implements a similar looking UI, in Windows http://www.malsmith.net/edit/Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

There were other interesting TUIs, the one in Defrag in DOS, and the Antivirus would change characters on the fly to generate a mouse cursor.The TUI in DOSSHELL.exe would use customise some characters to draw icons.Maybe Scott Hanselman could be persuaded to work on open sourcing all the COW apps.(Honarable mention for EDIT in DOS7, which appears to be a rewrite, supporting long filenames).In the modern era, there is YEdit from the author of YCmd, which implements a similar looking UI, in Windows http://www.malsmith.net/edit/Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

The TUI in DOSSHELL.exe would use customise some characters to draw icons.Maybe Scott Hanselman could be persuaded to work on open sourcing all the COW apps.(Honarable mention for EDIT in DOS7, which appears to be a rewrite, supporting long filenames).In the modern era, there is YEdit from the author of YCmd, which implements a similar looking UI, in Windows http://www.malsmith.net/edit/Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

Maybe Scott Hanselman could be persuaded to work on open sourcing all the COW apps.(Honarable mention for EDIT in DOS7, which appears to be a rewrite, supporting long filenames).In the modern era, there is YEdit from the author of YCmd, which implements a similar looking UI, in Windows http://www.malsmith.net/edit/Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

(Honarable mention for EDIT in DOS7, which appears to be a rewrite, supporting long filenames).In the modern era, there is YEdit from the author of YCmd, which implements a similar looking UI, in Windows http://www.malsmith.net/edit/Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

In the modern era, there is YEdit from the author of YCmd, which implements a similar looking UI, in Windows http://www.malsmith.net/edit/Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

Some other TUIs of note included the ones in Wordperfect, Norton Utilities, and of course TurboVision (though the last has implementations in modern environments).

![image](https://news.ycombinator.com/s.gif)

Someone linked: https://news.ycombinator.com/item?id=40293624

![image](https://news.ycombinator.com/s.gif)

These are enhanced printf(), scanf(), getc() type functions by adding cursor positioning on an 80x25 screen. Pretty basic but you could create nice applications with these basic functions in Zortech c.Granted, on DOS the screen size did not change as it does in UN*X, making TUIs easier.On the systems (minis) I worked on decades ago, TUIs were far easier then anything I have seen since.

Granted, on DOS the screen size did not change as it does in UN*X, making TUIs easier.On the systems (minis) I worked on decades ago, TUIs were far easier then anything I have seen since.

On the systems (minis) I worked on decades ago, TUIs were far easier then anything I have seen since.

![image](https://news.ycombinator.com/s.gif)

That's because DOS (well, the IBM PC really) had a memory-mapped text mode display buffer instead of terminal emulation.So much easier to fill a screen rapidly and do partial updates, scrolling, moving windows etc. when you can just do pointer arithmetic and memcpy.

So much easier to fill a screen rapidly and do partial updates, scrolling, moving windows etc. when you can just do pointer arithmetic and memcpy.

![image](https://news.ycombinator.com/s.gif)

FWIW, _everybody_ has a hard time with curses. That's why it's (aptly) named "curses!"

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://developer.mozilla.org/en-US/docs/Web/CSS/@media

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

I think this will demonstrate color with ANSI.SYS and/or VT-color: $ cat rgbdemo.sh #!/bin/sh alias p=printf N=$(p \\033) N="$N[" x=30 for a in Bl R G Y B M C W # Black Red Green Yellow Blue Magenta Cyan White do eval $a='$N'"'"$(( x))"m'" \ b$a='$N'"'"$((60 + x))"m'" \ ${a}bg='$N'"'"$((10 + x))"m'" \ b${a}bg='$N'"'"$((70 + x))"m'" # bX=bright Xbg=background bXbg=brgt bgnd x=$(( x + 1 )) done # https://en.wikipedia.org/wiki/ANSI_escape_code N=$N'0m' echo "I am $Wbg$R red, $G green, $B and blue $N on a white background."

$ cat rgbdemo.sh #!/bin/sh alias p=printf N=$(p \\033) N="$N[" x=30 for a in Bl R G Y B M C W # Black Red Green Yellow Blue Magenta Cyan White do eval $a='$N'"'"$(( x))"m'" \ b$a='$N'"'"$((60 + x))"m'" \ ${a}bg='$N'"'"$((10 + x))"m'" \ b${a}bg='$N'"'"$((70 + x))"m'" # bX=bright Xbg=background bXbg=brgt bgnd x=$(( x + 1 )) done # https://en.wikipedia.org/wiki/ANSI_escape_code N=$N'0m' echo "I am $Wbg$R red, $G green, $B and blue $N on a white background."

```
$ cat rgbdemo.sh #!/bin/sh alias p=printf N=$(p \\033) N="$N[" x=30 for a in Bl R G Y B M C W # Black Red Green Yellow Blue Magenta Cyan White do eval $a='$N'"'"$(( x))"m'" \ b$a='$N'"'"$((60 + x))"m'" \ ${a}bg='$N'"'"$((10 + x))"m'" \ b${a}bg='$N'"'"$((70 + x))"m'" # bX=bright Xbg=background bXbg=brgt bgnd x=$(( x + 1 )) done # https://en.wikipedia.org/wiki/ANSI_escape_code N=$N'0m' echo "I am $Wbg$R red, $G green, $B and blue $N on a white background."
```

![image](https://news.ycombinator.com/s.gif)

You might like "joe", which was inspired by WordStar: <https://joe-editor.sourceforge.io/>

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

there have been lots and lots of advancements in IDEs since then, are none of those advancements useful to you? not everyone needs or wants a lot of those things, i'm sure, but they have utility which the Turbo* console IDEs lacked.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

[0] https://github.com/justbur/emacs-which-key

![image](https://news.ycombinator.com/s.gif)

Tilde is a great EDIT.COM/Borland style IDE clone for Linux. It even has mouse support via remote Terminal.

![image](https://news.ycombinator.com/s.gif)

That's ridiculous! The only invisible things in Emacs deserve to be so. For everything else, there is a menu bar which is also visible in terminal `emacs -nw` mode. Just add `(xterm-mouse-mode t)` to ~/.emacs to make sure the mouse works properly. Very pointy, very clicky, and nice pretty menus that tell you the shortcut of each function.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

The thing you want (the helpful mouse interface) is the Emacs default. The funny command-line flag is what makes it weird. Just don't use that flag.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

> "Thank you so much to everyone for engaging with this feature exploration! Your passion has generated a ton of excitement in our own team, and I’m happy to share our proposed direction, which is that we will work with Malcolm Smith (malxau), the maintainer of Yedit, to ship Edit in Windows! We plan to do this by forking the Yedit code to a new OSS repo on GitHub, under Microsoft (like terminal or powertoys)."YEdit being an MIT licensed open-source recreation of the MS-DOS 5 editor, by a Microsoft employee: http://www.malsmith.net/edit/

YEdit being an MIT licensed open-source recreation of the MS-DOS 5 editor, by a Microsoft employee: http://www.malsmith.net/edit/

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://ratatui.rs/showcase/apps/https://github.com/ratatui-org/awesome-ratatuihttps://discord.com/channels/1070692720437383208/10729061831... (made with ratatui channel on our discord server)We encourage our users to use https://github.com/charmbracelet/vhs to build out demos that look neat.My particular favorite of the bunch (from a look and feel perspective) is https://github.com/zaghaghi/openapi-tuiAlso, not ratatui, but worth a look: https://github.com/rothgar/awesome-tuis

https://github.com/ratatui-org/awesome-ratatuihttps://discord.com/channels/1070692720437383208/10729061831... (made with ratatui channel on our discord server)We encourage our users to use https://github.com/charmbracelet/vhs to build out demos that look neat.My particular favorite of the bunch (from a look and feel perspective) is https://github.com/zaghaghi/openapi-tuiAlso, not ratatui, but worth a look: https://github.com/rothgar/awesome-tuis

https://discord.com/channels/1070692720437383208/10729061831... (made with ratatui channel on our discord server)We encourage our users to use https://github.com/charmbracelet/vhs to build out demos that look neat.My particular favorite of the bunch (from a look and feel perspective) is https://github.com/zaghaghi/openapi-tuiAlso, not ratatui, but worth a look: https://github.com/rothgar/awesome-tuis

We encourage our users to use https://github.com/charmbracelet/vhs to build out demos that look neat.My particular favorite of the bunch (from a look and feel perspective) is https://github.com/zaghaghi/openapi-tuiAlso, not ratatui, but worth a look: https://github.com/rothgar/awesome-tuis

My particular favorite of the bunch (from a look and feel perspective) is https://github.com/zaghaghi/openapi-tuiAlso, not ratatui, but worth a look: https://github.com/rothgar/awesome-tuis

Also, not ratatui, but worth a look: https://github.com/rothgar/awesome-tuis

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

* `ranger` file manager: https://ranger.github.io/* `ncdu` for visualising disk usage: https://dev.yorhel.nl/ncdu* `htop` process monitor: https://htop.dev/I just find them very intuitive, and information-dense while not being overwhelming.

* `ncdu` for visualising disk usage: https://dev.yorhel.nl/ncdu* `htop` process monitor: https://htop.dev/I just find them very intuitive, and information-dense while not being overwhelming.

* `htop` process monitor: https://htop.dev/I just find them very intuitive, and information-dense while not being overwhelming.

I just find them very intuitive, and information-dense while not being overwhelming.

![image](https://news.ycombinator.com/s.gif)

* `vifm` file manager, more powerful and performant than ranger, for those who lean towards vim keybindings: https://vifm.info/gallery.shtml* `btop` process monitor, for those who like eye candy: https://github.com/aristocratos/btop?tab=readme-ov-file#main...

* `btop` process monitor, for those who like eye candy: https://github.com/aristocratos/btop?tab=readme-ov-file#main...

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It's a lot faster in all aspects, has mostly the same features and is pretty much a standalone binary.edit: an even more minimal alteranative is nnn https://github.com/jarun/nnn

edit: an even more minimal alteranative is nnn https://github.com/jarun/nnn

![image](https://news.ycombinator.com/s.gif)

Someone took the time to rewrite it as a cross-platform open source library: https://github.com/magiblot/tvisionEdit: Not a rewrite, but a port. See comments below.

Edit: Not a rewrite, but a port. See comments below.

![image](https://news.ycombinator.com/s.gif)

https://en.wikipedia.org/wiki/IBM_TopView

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

I just now came across the following related to Turbo Vision:> TuiCss is a library focused to create web applications using an interface based on ASCII table, like the old MS-DOS applications. ...... The base of this project is Turbo Vision Framework, but some other frameworks were also checked to introduce some features to TuiCss, like curses, ncurses, Newt, etc.https://www.npmjs.com/package/tuicss

> TuiCss is a library focused to create web applications using an interface based on ASCII table, like the old MS-DOS applications. ...... The base of this project is Turbo Vision Framework, but some other frameworks were also checked to introduce some features to TuiCss, like curses, ncurses, Newt, etc.https://www.npmjs.com/package/tuicss

https://www.npmjs.com/package/tuicss

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

what i would like to see is a gui layer that wraps turbo vision such that i can have apps that work in the terminal and in a GUI. ideally so that the app binaries directly work in both without any recompile or change of code.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It has a huge number of data formats it can visualize, but I haven't taken the time to go through them all. What I do know is that it is great for viewing CSVs in a terminal. Even if I don't use it for anything else, that alone merits an install from me.

![image](https://news.ycombinator.com/s.gif)

https://github.com/YS-L/csvlens

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It’s a data exploration tool packed with features, but my regular use case is to just pipe some json into it to get a table view; it lets you easily explode nested fields into separate columns which I find tremendously helpful when digging

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

i like the conflict resolver, but one thing i didn't see is the ability to outright edit a commit. that is something i'd like to use occasionally

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

WordStar is another one, used by George RR Martin et al: https://arstechnica.com/information-technology/2017/03/words...

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Sometimes a terminal would desync while you were typing up a storm, spewing control codes onto the screen. Many re-re-learned the need for frequent saves.The WordPerfect spellchecker's short list of suggestions was typical of word processors, even decades later. A few of us knew to press the magic key to drop into a shell and use the mini's speller, which appeared to dump the whole wordlist, instantly sorted by similarity, one screen at a time. We could usually hop back into WordPerfect before anyone in charge asked why we weren't either at the system login screen or using WP. I never found another speller that worked like that.They never did get the upgrade cards for those terminals, to turn them into smart-terminals. PC 386s with Win3.11 were the next big investment.

The WordPerfect spellchecker's short list of suggestions was typical of word processors, even decades later. A few of us knew to press the magic key to drop into a shell and use the mini's speller, which appeared to dump the whole wordlist, instantly sorted by similarity, one screen at a time. We could usually hop back into WordPerfect before anyone in charge asked why we weren't either at the system login screen or using WP. I never found another speller that worked like that.They never did get the upgrade cards for those terminals, to turn them into smart-terminals. PC 386s with Win3.11 were the next big investment.

They never did get the upgrade cards for those terminals, to turn them into smart-terminals. PC 386s with Win3.11 were the next big investment.

![image](https://news.ycombinator.com/s.gif)

https://github.com/taviso/wpunix

![image](https://news.ycombinator.com/s.gif)

https://en.wikipedia.org/wiki/ISPFBecause the IBM mainframe world was late to the time-sharing party (ISPF was based on TSO, the Time-Sharing Option for System/360 and System/370, because the default mode for mainframes was batch processing from punched cards), and because IBM's 3270 terminal used screen-at-a-time updates instead of character-at-a-time, sending interrupts to the CPU only when Enter or a PF key was pressed, ISPF feels clunky and foreign compared to modern TUIs. But it really had a nice design, providing a vast improvement in UI to the mainframe in the form of a menu-driven interface, with a common API that application developers can use to take advantage of the same interface features as the system provides. There are even comprehensive help screens. Here's a demo of ISPF in action:https://www.youtube.com/watch?v=IWVD2yM3tsYThis interface, or something like it, is what my mom used during her early days as a customer service rep for a large insurance company back in the 90s. You tab between fields, mash Enter to send the whole form, or hit an F key to take various actions. She became quick and efficient at entering or updating customer data. Then they switched to an all-new, all-shiny J2EE app with a browser front end, and she was completely at sixes and sevens. She may as well have turned into a large insect like Gregor Samsa, because the new UI made her less productive, she was punished for it, and she was not allowed to train with the new UI.We think of mainframes as old and stodgy, but really what they were built to do they were great at: accepting and processing large amounts of business data and transactions. The workflow for that use case was incredibly streamlined, and modern software businesses could learn a lot from how the mainframe did things.

Because the IBM mainframe world was late to the time-sharing party (ISPF was based on TSO, the Time-Sharing Option for System/360 and System/370, because the default mode for mainframes was batch processing from punched cards), and because IBM's 3270 terminal used screen-at-a-time updates instead of character-at-a-time, sending interrupts to the CPU only when Enter or a PF key was pressed, ISPF feels clunky and foreign compared to modern TUIs. But it really had a nice design, providing a vast improvement in UI to the mainframe in the form of a menu-driven interface, with a common API that application developers can use to take advantage of the same interface features as the system provides. There are even comprehensive help screens. Here's a demo of ISPF in action:https://www.youtube.com/watch?v=IWVD2yM3tsYThis interface, or something like it, is what my mom used during her early days as a customer service rep for a large insurance company back in the 90s. You tab between fields, mash Enter to send the whole form, or hit an F key to take various actions. She became quick and efficient at entering or updating customer data. Then they switched to an all-new, all-shiny J2EE app with a browser front end, and she was completely at sixes and sevens. She may as well have turned into a large insect like Gregor Samsa, because the new UI made her less productive, she was punished for it, and she was not allowed to train with the new UI.We think of mainframes as old and stodgy, but really what they were built to do they were great at: accepting and processing large amounts of business data and transactions. The workflow for that use case was incredibly streamlined, and modern software businesses could learn a lot from how the mainframe did things.

https://www.youtube.com/watch?v=IWVD2yM3tsYThis interface, or something like it, is what my mom used during her early days as a customer service rep for a large insurance company back in the 90s. You tab between fields, mash Enter to send the whole form, or hit an F key to take various actions. She became quick and efficient at entering or updating customer data. Then they switched to an all-new, all-shiny J2EE app with a browser front end, and she was completely at sixes and sevens. She may as well have turned into a large insect like Gregor Samsa, because the new UI made her less productive, she was punished for it, and she was not allowed to train with the new UI.We think of mainframes as old and stodgy, but really what they were built to do they were great at: accepting and processing large amounts of business data and transactions. The workflow for that use case was incredibly streamlined, and modern software businesses could learn a lot from how the mainframe did things.

This interface, or something like it, is what my mom used during her early days as a customer service rep for a large insurance company back in the 90s. You tab between fields, mash Enter to send the whole form, or hit an F key to take various actions. She became quick and efficient at entering or updating customer data. Then they switched to an all-new, all-shiny J2EE app with a browser front end, and she was completely at sixes and sevens. She may as well have turned into a large insect like Gregor Samsa, because the new UI made her less productive, she was punished for it, and she was not allowed to train with the new UI.We think of mainframes as old and stodgy, but really what they were built to do they were great at: accepting and processing large amounts of business data and transactions. The workflow for that use case was incredibly streamlined, and modern software businesses could learn a lot from how the mainframe did things.

We think of mainframes as old and stodgy, but really what they were built to do they were great at: accepting and processing large amounts of business data and transactions. The workflow for that use case was incredibly streamlined, and modern software businesses could learn a lot from how the mainframe did things.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Nevertheless, it sports many IBM-isms in its design, including integrating database functionality directly into the operating system, making database tables and files almost coterminous with record-level file access being the primary mode of access; and the use of block-oriented, rather than character-oriented terminals (the IBM 5250).Interestingly unique to IBM i among IBM operating systems is the pervasive use of object orientation throughout its system APIs; there are no pointers, everything is an object over which some operations are permitted and others forbidden. While the mainframe series retained darn-near-perfect backwards compatibility through system-level emulation of old architectures on top of new architectures, IBM i's solution to this problem is different: TIMI (Technology Independent Machine Interface), a kernel-level abstract machine to which all IBM i applications are targeted. No programmer access to the underlying machine code is provided. Rather, the first time the kernel loads a TIMI executable, it AOT-compiles it to whatever the underlying CPU architecture it is. This enables seamless CPU architecture changes with perfect backwards compatibility for application code; this already happened in the 90s as the AS/400 line migrated from a System/38-based architecture to PowerPC.

Interestingly unique to IBM i among IBM operating systems is the pervasive use of object orientation throughout its system APIs; there are no pointers, everything is an object over which some operations are permitted and others forbidden. While the mainframe series retained darn-near-perfect backwards compatibility through system-level emulation of old architectures on top of new architectures, IBM i's solution to this problem is different: TIMI (Technology Independent Machine Interface), a kernel-level abstract machine to which all IBM i applications are targeted. No programmer access to the underlying machine code is provided. Rather, the first time the kernel loads a TIMI executable, it AOT-compiles it to whatever the underlying CPU architecture it is. This enables seamless CPU architecture changes with perfect backwards compatibility for application code; this already happened in the 90s as the AS/400 line migrated from a System/38-based architecture to PowerPC.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://www.youtube.com/watch?v=dP1xVpMPn8MThe entire UI is composed of text. You can place arbitrary commands anywhere on the screen. Interaction with other programs is natural and seamless. You're also not confined to the ANSI-terminal model. Perhaps most shockingly, Acme uses the mouse a lot.I find that there's a lot of confusion between text-based, CLI, and ANSI sequences. That's unfortunate.

The entire UI is composed of text. You can place arbitrary commands anywhere on the screen. Interaction with other programs is natural and seamless. You're also not confined to the ANSI-terminal model. Perhaps most shockingly, Acme uses the mouse a lot.I find that there's a lot of confusion between text-based, CLI, and ANSI sequences. That's unfortunate.

I find that there's a lot of confusion between text-based, CLI, and ANSI sequences. That's unfortunate.

![image](https://news.ycombinator.com/s.gif)

I have no idea where you'd be able to find it since it's a proprietary product but InfoLease 9 had one of my favorites TUIs from a long gone era. You could navigate through and edit complicated contract information extremely quickly through a series of fixed number based menus and views. Once I got the hang of it I could blaze through entering tons and tons of data without any effort. I suppose a lot of BBSes had a kind-of similar interface but without the field validation and documentation (you could write ? virtually anywhere to get quick documentation about what you were editing or what something was intended for, and fields were validated in this really "perfect" way where it never felt like you lost time if you fat-fingered something).

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

The 3D buttons in a TUI, event-based programming in DOS, the rich help system… just awesome.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

bandwhich: Terminal bandwidth utilization tool sc-im: A very capable terminal based spreadsheet program. bpytop: Linux/OSX/FreeBSD resource monitor broot: New way to see and navigate directory trees daff: provides efficient table comparison and alignment, supporting formats like CSV and SQLite, making it essential for data analysis and synchronization tasks. It's indispensable for those requiring accurate data comparisons in analysis, development, or data integration projects.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

fs = :filter -H<space>subject:"{{.SubjectBase}}" <Enter>To filter mails with the same subject. And additional the possibility to pipe everything through the shell, I don’t know what mutt can do that aerc can’t.

To filter mails with the same subject. And additional the possibility to pipe everything through the shell, I don’t know what mutt can do that aerc can’t.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

The Blackbox framework has a Windows GUI and is quite different from the Oberon System v1 and v2. Starting with v3 and the active object system (AOS), the Oberon System had also a GUI, even with a window manager. But Wirth went back to the original TUI in his FPGA based Project Oberon System (see https://www.projectoberon.net/); here is a version or this system which runs on all platforms: https://github.com/rochus-keller/OberonSystem.

![image](https://news.ycombinator.com/s.gif)

It has been converted to be a Windows app and still is for sale, it seems doesn’t try hard to sell stuff (“For pricing information call or email us”), but its site (https://framework.com/) and doesn’t do the product justice, to be kind.I couldn’t find a good demo either. https://youtu.be/RKR42Gmrydo?si=ILGJFiY33cFmcZ-o will have to do, but doesn’t show at all how easy it was to write small programs manipulating frames.

I couldn’t find a good demo either. https://youtu.be/RKR42Gmrydo?si=ILGJFiY33cFmcZ-o will have to do, but doesn’t show at all how easy it was to write small programs manipulating frames.

![image](https://news.ycombinator.com/s.gif)

Bezroukov has written about the type of TUI he calls "orthodox interfaces" and he does it more justice than I can: https://softpanorama.org/Articles/introduction_to_orthodox_f...

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

I actually really hated it, because there was a six character limit meaning that most stuff had to be abbreviated. A double cheeseburger was "DBLCHZ", McNuggets were "MCNUGS", Fillets of Fish were "FIOFIS". I got used to it eventually, but learning was a huge pain because you're at the whim of figuring the abbreviation of whomever programmed the machine.Still, it's better than a lot of other fast food kiosks that I heard people use, where they didn't even have words, just pictures, which I think I'd hate even more.

Still, it's better than a lot of other fast food kiosks that I heard people use, where they didn't even have words, just pictures, which I think I'd hate even more.

![image](https://news.ycombinator.com/s.gif)

chown MCNUGS, please!

![image](https://news.ycombinator.com/s.gif)

None of them were vulgar or anything, but for example we had taken to calling one of the managers "McNugs" because he stole a bunch of chicken nuggets (like literally a whole box, not just one or two from the line), tried to claim that the workers did it, and we actually needed to get the security footage to exonerate us, and surprisingly he wasn't fired for it. We all started calling him McNugs, which he absolutely hated, but I think he was afraid to do anything about it because he was already on thin ice for trying to frame us.I might have them written down somewhere, I'll have to look.

I might have them written down somewhere, I'll have to look.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

They noticed because we ran out of them during a rush hour and the owner of the franchise was confused because we should have had another box.

![image](https://news.ycombinator.com/s.gif)

cointop: https://github.com/cointop-sh/cointop

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

This one is more a layer 8 issue perhaps, but ideally there is some sort of guard rail that makes it so that if I accidentally start typing a message I think is going into slack, but I still have the tui focused, doesn’t execute a ton of very hard to reverse actions. Perhaps a good undo/redo stack is enough here, but some sort of vim like modality could work even better. It doesn’t happen often, but if it’s something like k9s the blast radius is… pretty big!

![image](https://news.ycombinator.com/s.gif)

[0] https://en.wikipedia.org/wiki/Menuconfig[1] https://sourceware.org/gdb/current/onlinedocs/gdb.html/TUI.h...

[1] https://sourceware.org/gdb/current/onlinedocs/gdb.html/TUI.h...

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

An example: http://img1.51cto.com/attachment/201204/133704226.jpg

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

WordStar and WordPerfect both were also fantastic things from that era that took advantage of the terminal environment.Also, many IBM 3270 "green screen" apps in banks, stores, airlines, etc. were actually extremely well thought through. In the 90s they would get maligned and replaced with "better" Windows client-server GUIs, but usually the GUI was in the end inferior in terms of workflow and reliability.When I was a minimum wage employee at Canadian Tire early 90s, the green-screen terminal-based inventory system was odd and unorthodox but actually very quick to work with and with decent design.

Also, many IBM 3270 "green screen" apps in banks, stores, airlines, etc. were actually extremely well thought through. In the 90s they would get maligned and replaced with "better" Windows client-server GUIs, but usually the GUI was in the end inferior in terms of workflow and reliability.When I was a minimum wage employee at Canadian Tire early 90s, the green-screen terminal-based inventory system was odd and unorthodox but actually very quick to work with and with decent design.

When I was a minimum wage employee at Canadian Tire early 90s, the green-screen terminal-based inventory system was odd and unorthodox but actually very quick to work with and with decent design.

![image](https://news.ycombinator.com/s.gif)

This way I can quickly record on Mac, with some interaction, and of course, since this is Rust and ratatui [2], this tool should also be cross-platform.[1] https://github.com/chaosprint/asak[2] https://ratatui.rs/

[1] https://github.com/chaosprint/asak[2] https://ratatui.rs/

[2] https://ratatui.rs/

![image](https://news.ycombinator.com/s.gif)

All can be run in a TTY to get that TUI experience.

![image](https://news.ycombinator.com/s.gif)

https://docs.sweeting.me/s/system-monitoring-toolsThere's also this list: https://github.com/rothgar/awesome-tuisIn particular ones I haven't seen mentioned already are:pudb (gdb for python), glances (better htop), memray, fdisk, ctop (htop for docker), dissy (dissasembler), fzf (file browser), micro (like nano meets Sublime Text), hexyl (hex viewer)

There's also this list: https://github.com/rothgar/awesome-tuisIn particular ones I haven't seen mentioned already are:pudb (gdb for python), glances (better htop), memray, fdisk, ctop (htop for docker), dissy (dissasembler), fzf (file browser), micro (like nano meets Sublime Text), hexyl (hex viewer)

In particular ones I haven't seen mentioned already are:pudb (gdb for python), glances (better htop), memray, fdisk, ctop (htop for docker), dissy (dissasembler), fzf (file browser), micro (like nano meets Sublime Text), hexyl (hex viewer)

pudb (gdb for python), glances (better htop), memray, fdisk, ctop (htop for docker), dissy (dissasembler), fzf (file browser), micro (like nano meets Sublime Text), hexyl (hex viewer)

![image](https://news.ycombinator.com/s.gif)

The tui controls are quite intuitive if you know vim, and a lot of them are basically abbreviations, like ts for torrent start/stop, tm for torrent move (setting path), tn for torrent name (rename top level dir/file of the torrent), td for torrent delete. The command mode in the tui is also quite flexible. You use :add to add a torrent by url or file path, and you can specify -s to add in stopped state and -p to specify the path for all those torrents, but those args can go before or after the torrents. Depending if I have the path or torrent on my clipboard first I'll write out the command differently. Often I use primary selection to grab a torrent url from my IRC client and then my clipboard manager of sorts to slap a path on my clipboard and paste both in quick succession.I keep it running in tmux on my server and can add torrents from my phone or PC over ssh. It can connect to remote Transmission sessions, but my distro doesn't package it so I just run it on the same server as Transmission. In the past I used other frontends for Transmission and Deluge, but none are nearly as good as stig.

I keep it running in tmux on my server and can add torrents from my phone or PC over ssh. It can connect to remote Transmission sessions, but my distro doesn't package it so I just run it on the same server as Transmission. In the past I used other frontends for Transmission and Deluge, but none are nearly as good as stig.

![image](https://news.ycombinator.com/s.gif)

to a lesser extent: btop, htop (but I find the shortcuts confusing), csvlens (https://github.com/YS-L/csvlens), lynx (elinks, links).

![image](https://news.ycombinator.com/s.gif)

https://en.wikipedia.org/wiki/Slrnhttps://en.wikipedia.org/wiki/Mutt_(email_client)https://en.wikipedia.org/wiki/Ncdu

https://en.wikipedia.org/wiki/Mutt_(email_client)https://en.wikipedia.org/wiki/Ncdu

https://en.wikipedia.org/wiki/Ncdu

![image](https://news.ycombinator.com/s.gif)

Thanks for listing it.

![image](https://news.ycombinator.com/s.gif)

It's especially great if the server is out of disk space and/or the server is under too heavy a load to keep an SSH connection going; you can investigate what's clogging up space (usually logfiles gone awry) and clean up accordingly.It's one of the default utilities I have installed on my servers for a very good reason and it's helped out countless times over the past few years for hobby servers of mine (aka the ones where "scaling it up" isn't an option because the budget is constrained by it being a hobby).

It's one of the default utilities I have installed on my servers for a very good reason and it's helped out countless times over the past few years for hobby servers of mine (aka the ones where "scaling it up" isn't an option because the budget is constrained by it being a hobby).

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

And I feel like all those UNIX lovers going on and on about how efficient command line tools are don't get this at all. For a command like "replace 'foo' with 'bar' in lines 1237-1451" to make sense, you either need superhuman memory, or a printout nearby. And if you don't use it every day, you'll also need to look up the exact syntax for that command.PCs running MS-DOS might have been less powerful than UNIX machines, but they got really good, discoverable text user interfaces that took advantage of the hardware available, and could access that hardware in the most direct way. The best that is available now on Linux are really just pale imitations, and have to go through layers of terminal libraries and ugly hacks, like connecting to the X server in order to get the state of modifier keys that the terminal doesn't send.

PCs running MS-DOS might have been less powerful than UNIX machines, but they got really good, discoverable text user interfaces that took advantage of the hardware available, and could access that hardware in the most direct way. The best that is available now on Linux are really just pale imitations, and have to go through layers of terminal libraries and ugly hacks, like connecting to the X server in order to get the state of modifier keys that the terminal doesn't send.

![image](https://news.ycombinator.com/s.gif)

This is how I feel about emacs. Sure it contains the world, but you have to memorize the map to get anywhere interesting. I do like emacs and I do use it daily, but my command repertoire is under a dozen in number.

![image](https://news.ycombinator.com/s.gif)

- K9s: replaced my use of kubectl and the K8s dashboard. Lets you go from browse —> action on a resource so much faster than kubectl.- btop: it’s like top, but way prettier.

- btop: it’s like top, but way prettier.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://www.pa3fwm.nl/software/puff/

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

You could build a relational database and lookup and entry forms for an app all in a tui.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

I've been looking at https://github.com/gui-cs/Terminal.Gui but haven't tried it yet.

![image](https://news.ycombinator.com/s.gif)

* Information dense screens (despite having only 80x25 characters)* Responsiveness* Reliable type-ahead when the responsiveness wasn't quite good enough

* Responsiveness* Reliable type-ahead when the responsiveness wasn't quite good enough

* Reliable type-ahead when the responsiveness wasn't quite good enough

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

[1] https://en.wikipedia.org/wiki/Teletext[2] https://en.wikipedia.org/wiki/Minitel

[2] https://en.wikipedia.org/wiki/Minitel

![image](https://news.ycombinator.com/s.gif)

Definitely, the buffer-based metaphor rocks, and that way of working with things was kind of lost outside of emacs.

![image](https://news.ycombinator.com/s.gif)

Toolong is a log file viewer / tailer (https://github.com/Textualize/toolong)

![image](https://news.ycombinator.com/s.gif)

But if Emacs isn't a requirement, you might have an easier time doing many TUI things in Python or Rust, with one of their fancy libraries. Emacs can be made to emulate things like cursor-addressing, but the underlying representation, and the features layered upon it, aren't designed for that, and you have to fight them.(BTW, after seeing the Canon Cat again on HN the other day, and realizing that the pointer buttons on a TrackPoint keyboard are just sitting there, waiting to be Leap keys, I had the thought of implementing that.)

(BTW, after seeing the Canon Cat again on HN the other day, and realizing that the pointer buttons on a TrackPoint keyboard are just sitting there, waiting to be Leap keys, I had the thought of implementing that.)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It mostly used single letter commands modelessly on the keyboard, if I recall, like 'd' to delete files, I think, probably with a confirmation like 'y/n' after you hit 'd'. It was written in ASM. I'm not 100% sure, I just remember how amazingly fast and frictionless it felt after getting used to it.it was dual-pane. it was probably influenced by other commander/shells, like the Norton Commander, but when I got good with this, it was so fast. It was like using vim purely in edit (not insert) mode the friction of switching modes for managing your files. And you could use the mouse.

it was dual-pane. it was probably influenced by other commander/shells, like the Norton Commander, but when I got good with this, it was so fast. It was like using vim purely in edit (not insert) mode the friction of switching modes for managing your files. And you could use the mouse.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

[0] https://github.com/jesseduffield/lazydocker

![image](https://news.ycombinator.com/s.gif)

Over the decades I went to the museum often and the future turned into the past. It's only recently when the museum got a new director and a huge renovation when the old machines with the blue CRT monitors disappeared. I wonder what happened to them...[1] https://www.deutsches-museum.de/en

[1] https://www.deutsches-museum.de/en

![image](https://news.ycombinator.com/s.gif)

Yes! It's very surprising how small it was. Images back in the day gave the impression of a hulking monolith.

![image](https://news.ycombinator.com/s.gif)

http://acme.cat-v.org/

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Windows Commander/Total Commander are also NC clones, but implemented as GUI instead of TUI.NC was one of the most convenient UIs for managing files, it’s a pity none of the major operating systems adopted this style for their default file managers.

NC was one of the most convenient UIs for managing files, it’s a pity none of the major operating systems adopted this style for their default file managers.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

- neomutt (email client)- ncspot (Rust Spotify client)- glirc (Haskell IRC client)- newsboat (RSS reader)- calcurse (calendar)

- ncspot (Rust Spotify client)- glirc (Haskell IRC client)- newsboat (RSS reader)- calcurse (calendar)

- glirc (Haskell IRC client)- newsboat (RSS reader)- calcurse (calendar)

- newsboat (RSS reader)- calcurse (calendar)

- calcurse (calendar)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

[1] https://github.com/ClementTsang/bottom

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Some things I don't like about modern TUIs is developers getting away from the purpose of them, portability. Often you'll find really beautiful TUIs that require installation of custom fonts for icons and other overcomplicated stuff like that. They can be nice, but generally they sacrifice the practical benefit to a significant degree.One I discovered yesterday, not really a TUI, more of a shell but still, extremely powerful, is kalc https://github.com/bgkillas/kalc which is a complete scientific and graphing calculator in the terminal. It depends on gnuplot for graphing, which is unfortunate since it is a GUI program, but there we go with composability again! It's fine and works and does what it needs to, so not really a big deal I guess.I also use Helix editor and sc-im daily.To find more:https://github.com/rothgar/awesome-tuishttps://github.com/toolleeo/cli-apps

One I discovered yesterday, not really a TUI, more of a shell but still, extremely powerful, is kalc https://github.com/bgkillas/kalc which is a complete scientific and graphing calculator in the terminal. It depends on gnuplot for graphing, which is unfortunate since it is a GUI program, but there we go with composability again! It's fine and works and does what it needs to, so not really a big deal I guess.I also use Helix editor and sc-im daily.To find more:https://github.com/rothgar/awesome-tuishttps://github.com/toolleeo/cli-apps

I also use Helix editor and sc-im daily.To find more:https://github.com/rothgar/awesome-tuishttps://github.com/toolleeo/cli-apps

To find more:https://github.com/rothgar/awesome-tuishttps://github.com/toolleeo/cli-apps

https://github.com/rothgar/awesome-tuishttps://github.com/toolleeo/cli-apps

https://github.com/toolleeo/cli-apps

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Something that can be used to present some simple TUI on a largish LCD based on a simple 1-wire UART interface in a semi-standardized, performant and cheap way (good quality IPS displays are ~ 6-10 EUR, and tang nano is 10-20 EUR, depending on model).https://megous.com/dl/tmp/tty-fpga.mp4It also implements an efficient "scrolling" output mode, so it can simply be connected to anything that produces debug output on UART, too. Use cases are pretty flexible. Smallest Microchip PIC MCU can easily present a reasonably nice UI. :)It can also accept input over the Tang Nano's USB UART directly from the connected PC (which is what's on the video).At 3 Mbaud, it's possible to keep updating the content of whole screen at 50 FPS from a simple MCU, over a single wire at easily manageable interface frequencies. Anyhting less, like incremental changes to subset of screen content via ANSI escape sequences pretty much runs at 60FPS/display's refresh rate.It's based on Tang Nano 9k currently, but it should fit even Tang Nano 1k, which is a bit cheaper.

https://megous.com/dl/tmp/tty-fpga.mp4It also implements an efficient "scrolling" output mode, so it can simply be connected to anything that produces debug output on UART, too. Use cases are pretty flexible. Smallest Microchip PIC MCU can easily present a reasonably nice UI. :)It can also accept input over the Tang Nano's USB UART directly from the connected PC (which is what's on the video).At 3 Mbaud, it's possible to keep updating the content of whole screen at 50 FPS from a simple MCU, over a single wire at easily manageable interface frequencies. Anyhting less, like incremental changes to subset of screen content via ANSI escape sequences pretty much runs at 60FPS/display's refresh rate.It's based on Tang Nano 9k currently, but it should fit even Tang Nano 1k, which is a bit cheaper.

It also implements an efficient "scrolling" output mode, so it can simply be connected to anything that produces debug output on UART, too. Use cases are pretty flexible. Smallest Microchip PIC MCU can easily present a reasonably nice UI. :)It can also accept input over the Tang Nano's USB UART directly from the connected PC (which is what's on the video).At 3 Mbaud, it's possible to keep updating the content of whole screen at 50 FPS from a simple MCU, over a single wire at easily manageable interface frequencies. Anyhting less, like incremental changes to subset of screen content via ANSI escape sequences pretty much runs at 60FPS/display's refresh rate.It's based on Tang Nano 9k currently, but it should fit even Tang Nano 1k, which is a bit cheaper.

It can also accept input over the Tang Nano's USB UART directly from the connected PC (which is what's on the video).At 3 Mbaud, it's possible to keep updating the content of whole screen at 50 FPS from a simple MCU, over a single wire at easily manageable interface frequencies. Anyhting less, like incremental changes to subset of screen content via ANSI escape sequences pretty much runs at 60FPS/display's refresh rate.It's based on Tang Nano 9k currently, but it should fit even Tang Nano 1k, which is a bit cheaper.

At 3 Mbaud, it's possible to keep updating the content of whole screen at 50 FPS from a simple MCU, over a single wire at easily manageable interface frequencies. Anyhting less, like incremental changes to subset of screen content via ANSI escape sequences pretty much runs at 60FPS/display's refresh rate.It's based on Tang Nano 9k currently, but it should fit even Tang Nano 1k, which is a bit cheaper.

It's based on Tang Nano 9k currently, but it should fit even Tang Nano 1k, which is a bit cheaper.

![image](https://news.ycombinator.com/s.gif)

https://www.unix-ag.uni-kl.de/~guenther/unix-tools-for-real-...

![image](https://news.ycombinator.com/s.gif)

The goal is to have a fully distributed multi UI ERP system, with TUI, web, android, ios, etc. all native. It's moving forward every year :)

![image](https://news.ycombinator.com/s.gif)

PyPI: https://pypi.org/project/logmerger/ Github: https://github.com/ptmcg/logmerger (screenshots in README)

![image](https://news.ycombinator.com/s.gif)

http://pascal.hansotten.com/ucsd-p-system/cp-m-and-ucsd-p-sy...As for more modern stuff, I like using ncdu and htop.

As for more modern stuff, I like using ncdu and htop.

![image](https://news.ycombinator.com/s.gif)

https://github.com/leg100/pugIt's built using Go and the bubbletea library. It's been a breath of fresh air compared to building a web app, simpler and faster to develop and test. And of course far more responsive than a web app could ever be.

It's built using Go and the bubbletea library. It's been a breath of fresh air compared to building a web app, simpler and faster to develop and test. And of course far more responsive than a web app could ever be.

![image](https://news.ycombinator.com/s.gif)

https://www.x-cmd.com/

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It's pretty good but I had to add a bit of sub-process parallelization since I have a long running process in the background.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Don't look too closely at the specific code, it is all custom to my own use and that's my point: thanks to fzf it is trivial to build powerful TUIs with minimal code, so minimal in fact that you, the user, can do it yourself. Configuration is unneeded because your own actions are the configuration.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It looked like your typical 16 color monospaced DOS TUI and was definitely intuitive to start with, but for the set of things I had to do, it was fast and fluid to use once one developed fluency with it’s layout and controls. I actually kind of miss it.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

PC-FAND is now on github... I think you should be good with Google Translate https://github.com/alisoss/pcfand

![image](https://news.ycombinator.com/s.gif)

https://github.com/mkramlich/slartboz-pub

![image](https://news.ycombinator.com/s.gif)

It was a neat way of surfacing lots of commands without taking up any screen-space.

![image](https://news.ycombinator.com/s.gif)

[0]: https://en.wikipedia.org/wiki/ALL-IN-1

![image](https://news.ycombinator.com/s.gif)

https://goaccess.io/

![image](https://news.ycombinator.com/s.gif)

https://rybczak.net/ncmpcpp https://wiki.archlinux.org/title/ncmpcpp

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

It gives a graphical interactive environment in terminal. Has some premade interfaces like spreadsheet, notepad and few others.It used to have a site where you could just connect via ssh and see interact with it in all its glory.

It used to have a site where you could just connect via ssh and see interact with it in all its glory.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://github.com/joouha/euporieIt consists of a TUI editor (and interactive REPL) for Jupyter notebooks, and supports displaying rich output in the terminal (images, LaTeX, HTML, interactive widgets, etc.).

It consists of a TUI editor (and interactive REPL) for Jupyter notebooks, and supports displaying rich output in the terminal (images, LaTeX, HTML, interactive widgets, etc.).

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

There are also programs that function more similar to "monoliths" but still act like a shell or repl as far as accepting commands and executing them. Clifm [2] is one example, it's the only file manager I seriously tried using before giving up and returning to ls and friends. If you have vi or any of its discendents odds are you can run them in "ex" mode where you use them similar to the good old ed. Speaking of ed, edbrowse [3] is a browser with an ed-like interface that can also read mail (and no I'm not making it up. An interesting thing about it (well, at least one of them) is that one can define "functions" which are pretty similar to functions in sh. For example, this is a function to search something on searx:``` function+gg { db0 b https://searx.be/ /<>/ i=~0 db1 /start search/i i2* /h1/ } ```While this can certainly be done in a conventional browser using userscripts or such, I'd argue that this sort of function is easier to write because most of it is something you were doing already, and now you're just putting it in a shorthand, where in a userscript you'd probably have to use a lot of getElementById()s to do it, which besides being more verbose is very different to how you think about the problem.[0]: https://www.nongnu.org/nmh/ [1]: https://github.com/leahneukirchen/mblaze [2]: https://leo-arch.github.io/clifm/ [3]: https://edbrowse.org/

``` function+gg { db0 b https://searx.be/ /<>/ i=~0 db1 /start search/i i2* /h1/ } ```While this can certainly be done in a conventional browser using userscripts or such, I'd argue that this sort of function is easier to write because most of it is something you were doing already, and now you're just putting it in a shorthand, where in a userscript you'd probably have to use a lot of getElementById()s to do it, which besides being more verbose is very different to how you think about the problem.[0]: https://www.nongnu.org/nmh/ [1]: https://github.com/leahneukirchen/mblaze [2]: https://leo-arch.github.io/clifm/ [3]: https://edbrowse.org/

While this can certainly be done in a conventional browser using userscripts or such, I'd argue that this sort of function is easier to write because most of it is something you were doing already, and now you're just putting it in a shorthand, where in a userscript you'd probably have to use a lot of getElementById()s to do it, which besides being more verbose is very different to how you think about the problem.[0]: https://www.nongnu.org/nmh/ [1]: https://github.com/leahneukirchen/mblaze [2]: https://leo-arch.github.io/clifm/ [3]: https://edbrowse.org/

[0]: https://www.nongnu.org/nmh/ [1]: https://github.com/leahneukirchen/mblaze [2]: https://leo-arch.github.io/clifm/ [3]: https://edbrowse.org/

![image](https://news.ycombinator.com/s.gif)

It created a simple dialog-based menu that allow to explore topic and search through them (and edit and print). I think it used Turbo-Vision, but I may be misremembering.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

I wouldn't be surprised if it was still in use now.

![image](https://news.ycombinator.com/s.gif)

https://github.com/victorqribeiro/beautyhairThe text is in PT but I guess you can understand it. I loved writing those CLI applications in Java back then.

The text is in PT but I guess you can understand it. I loved writing those CLI applications in Java back then.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Even better, a MOO (or any MUD) client in emacs (rmoo.el, mud.el etc), which is how I got my start with emacs eons ago.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://en.wikipedia.org/wiki/Lynx_(web_browser)

![image](https://news.ycombinator.com/s.gif)

http://elinks.cz/ + https://github.com/rkd77/elinks

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

One of the neatest things of my client is that I can cycle through unified diffs of the history of one page with a single key stroke. It's not perfect (macros are a problem) but good enough for me.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

I consider it MeWare: written for me, but published for others to use because why not? But don't expect a polished product.

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://github.com/extrawurst/gitui

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

Please let me know if someone actually tries this!https://github.com/Textualize/rich

https://github.com/Textualize/rich

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

https://k9scli.io/

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

There's also k9s: https://k9scli.io/And of course htop and nano!

And of course htop and nano!

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

* Vim ;)

![image](https://news.ycombinator.com/s.gif)

https://github.com/ggerganov/imtui

![image](https://news.ycombinator.com/s.gif)

Large inspiration for the overall UX comes from the Bloomberg terminal, where every function is reachable with four letter shortcut from the command box. It was really the command box that I liked. I've also built a sort of "flex" panel component for the layout so you can create as many panels as you like.https://docs.hofstadter.io/getting-started/hof-tui/https://github.com/hofstadter-io/hof/tree/_dev/lib/tuiThis was built on the tview/tcell stack in Go. There is also the Charm.sh stack that takes a different approach but is generally prettier and more polished (having a company behind it)

https://docs.hofstadter.io/getting-started/hof-tui/https://github.com/hofstadter-io/hof/tree/_dev/lib/tuiThis was built on the tview/tcell stack in Go. There is also the Charm.sh stack that takes a different approach but is generally prettier and more polished (having a company behind it)

https://github.com/hofstadter-io/hof/tree/_dev/lib/tuiThis was built on the tview/tcell stack in Go. There is also the Charm.sh stack that takes a different approach but is generally prettier and more polished (having a company behind it)

This was built on the tview/tcell stack in Go. There is also the Charm.sh stack that takes a different approach but is generally prettier and more polished (having a company behind it)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

dive https://github.com/wagoodman/dive

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)

![image](https://news.ycombinator.com/s.gif)